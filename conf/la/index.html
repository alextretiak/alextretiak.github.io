
<!-- saved from url=(0055)file:///C:/Users/DNS/AppData/Local/Temp/pq_to_html.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!--<base target="_blank">--><base href="." target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 190%; line-height: 120%;}
h2 {font-size: 160%;}
h3 {font-size: 137.5%;}
h4 {font-size: 120%;}
h5 {font-size: 110%;}
h6 {font-size: 100%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<table>
<tbody><tr><td><br>
<div align="center"><b>Лексический анализ,<br>
основанный на отступах</b></div>
<br>
</td></tr>
</tbody></table>
<!--[[[
Ключевые слова: лексический анализатор, компилятор, [[[языки программирования]/]]программирование.
]]]-->В данном докладе <!--[[[речь пойдёт]]/]-->говорится о лексическом анализаторе, который является неотъемлемой частью любого компилятора.<br>
Компилятор — это компьютерная программа, которая транслирует другие компьютерные программы для их выполнения.<br>
Цель данной работы — показать значимость учёта отступов при разработке лексического анализатора.<br>
<br>
Задача лексического анализатора заключается в том, чтобы разбить исходный текст программы на лексемы или токены.<br>
<hr>
<table>
<tbody><tr><td><br>
<div align="center"><style>
span.keyword {color: #0000FF; font-weight: bold;}
span.identifier {color: #00009F;}
span.string-literal {color: #800000;}
span.numeric-literal {color: #008000;}
span.constant {color: #008000;}
span.comment {color: #808080;}
</style><pre style="display: inline"><span class="identifier">print</span>(<span class="numeric-literal">1</span> + <span class="numeric-literal">2</span>)</pre><br>
↓<br>
<pre class="inline_code">print</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">1</pre>, <pre class="inline_code">+</pre>, <pre class="inline_code">2</pre>, <pre class="inline_code">)</pre><br>
<br>
</div>
</td></tr>
</tbody></table>
Так, например, код<br>
<pre style="display: inline"><span class="identifier">print</span>(<span class="numeric-literal">1</span> + <span class="numeric-literal">2</span>)</pre><br>
будет разбит на лексемы<br>
<pre class="inline_code">print</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">1</pre>, <pre class="inline_code">+</pre>, <pre class="inline_code">2</pre> и <pre class="inline_code">)</pre><br>
<br>
Исторически так сложилось, что компилятор большинства языков программирования отбрасывает все символы разделители, такие как пробел, табуляция и символ перевода строки. К чему это приводит? К тому, что компилятор видит исходный код так:<br>
<hr>
<table>
<tbody><tr><td><pre class="code_block"><span class="keyword">if</span> (<span class="identifier">foo</span>)
   <span class="keyword">if</span> (<span class="identifier">bar</span>)
      <span class="identifier">m1</span>();
<span class="keyword">else</span>
   <span class="identifier">m2</span>();
</pre>
<div align="center">↓</div>
<br>
<pre class="inline_code">if</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">foo</pre>, <pre class="inline_code">)</pre>, <pre class="inline_code">if</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">bar</pre>, <pre class="inline_code">)</pre>,<br>
<pre class="inline_code">m1</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">)</pre>, <pre class="inline_code">;</pre>, <pre class="inline_code">else</pre>, <pre class="inline_code">m2</pre>, <pre class="inline_code">(</pre>, <pre class="inline_code">)</pre>, <pre class="inline_code">;</pre><br>
</td></tr>
</tbody></table>
Данный код взят из <a href="https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop">документации к языку программирования Nemerle</a>. Он содержит так называемый баг висящего<!--[[[\dangling]]]--> else, заключающийся в том, что при взгляде на данный код можно подумать, что ветка else<!--[[[|els|]]]--> относится к условию foo, тогда как в языках программирования, синтаксис которых основан на языке Си (включая С++, С#, Java и другие), ветка else относится к условию bar.<br>
В качестве решения данной проблемы разработчики языка Nemerle ввели такое правило, что оператор if должен всегда иметь ветку else, а если ветка else не требуется, то вместо if следует использовать оператор when.<br>
Во многих новых языках программирования, например в Swift, Rust и Go, обязательно использовать фигурные скобки даже если тело оператора if <span class="sq"><span class="sq_brackets">[</span>и других операторов управления<span class="sq_brackets">]</span></span> состоит лишь из одной строки. При использовании фигурных скобок данная проблема пропадает<!--[[[/исчезает]]]-->:<br>
<hr>
<table>
<tbody><tr><td><pre class="code_block"><span class="keyword">if</span> (<span class="identifier">foo</span>) {
   <span class="keyword">if</span> (<span class="identifier">bar</span>) {
      <span class="identifier">m1</span>();
   }
}
<span class="keyword">else</span> {
   <span class="identifier">m2</span>();
}
</pre>
</td></tr>
</tbody></table>
В некоторых стандартах кодирования, например <a href="https://docs.oracle.com/cd/E12517_01/back_office/pdf/141/html/pos_impg2/developmentstandards.htm" title="&lt;- google:‘oracle coding standard’">от Oracle</a>, <a href="https://stanford.edu/class/archive/cs/cs106b/cs106b.1158/styleguide.shtml" title="&lt;- https://tproger.ru/translations/stanford-cpp-style-guide/ &lt;- google:‘c++ code style’">от Стэнфордского университета</a> или <a href="https://wiki.sei.cmu.edu/confluence/display/c/EXP19-C.+Use+braces+for+the+body+of+an+if,+for,+or+while+statement">Университета Карнеги — Меллона</a>, стоит требование заключать тело операторов if и else в фигурные скобки, чтобы исключить такую ошибку:<!--[[[
>[https://google.github.io/styleguide/cppguide.html <- google:‘c++ code style google’]:‘if must always have an accompanying brace’
>[https://users.ece.cmu.edu/~eno/coding/CCodingStandard.html <- google:‘c++ code style if must always have an accompanying brace’]:‘
All if, while and do statements require braces even if there is only a single statement within the braces. ...
It ensures that when someone adds a line of code later there are already braces and they don't forget.’
>[https://www.oracle.com/java/technologies/javase/codeconventions-statements.html <- google:‘require braces even if there is only a single statement within the braces’]:‘
. Braces are used around all statements, even single statements, when they are part of a control structure, such as an if-else or for statement. This makes it easier to add statements without accidentally introducing bugs due to forgetting to add braces.’
]]]--><br>
<hr>
<table>
<tbody><tr><td><pre class="code_block"><span class="identifier">int</span> <span class="identifier">login</span>;
 
<span class="keyword">if</span> (<span class="identifier">invalid_login</span>())
    <span class="identifier">login</span> = <span class="numeric-literal">0</span>;
<span class="keyword">else</span>
    <span class="identifier">printf</span>(<span class="string-literal">"Login is valid\n"</span>);
    <span class="identifier">login</span> = <span class="numeric-literal">1</span>;
</pre>
</td></tr>
</tbody></table>
Здесь строка <pre class="inline_code">login = 1</pre> будет выполнена в любом случае, независимо от того, какое значение вернула функция <pre class="inline_code">invalid_login</pre>.<br>
<br>
Но в обоих приведённых случаях проблема вовсе не в неправильной логике if <span class="sq"><span class="sq_brackets">[</span>допускающем как отсутствие ветви else, так и её наличие<span class="sq_brackets">]</span></span>, и даже не в забытых фигурных скобках, а в... расхождении в восприятии данного кода человеком-программистом и компилятором. Человек воспринимает границы блоков визуально, <!--[[[в первую очередь ]]]-->посредством отступов, а компилятор — посредством <span class="sq"><span class="sq_brackets">[</span>малоприметных для человека<span class="sq_brackets">]</span></span> символов, причём компилятор <span class="sq"><span class="sq_brackets">[</span>языков C/C++, C#, Java, Nemerle и др.<span class="sq_brackets">]</span></span> объединяет все "пробельные" символы <span class="sq"><span class="sq_brackets">[</span>разделители<span class="sq_brackets">]</span></span>, и, таким образом, напрочь игнорирует отступы. Вот в этом и заключается <b>корень проблемы — компилятор и человек видят такой код по-разному</b>.<br>
И решение данной проблемы я вижу в том, чтобы лексический анализ:<br>
<ul>
<li>был основан на отступах во всех новых языках программирования;</li>
<li>учитывал отступы в существующих языках программирования таким образом, чтобы приведённые ранее примеры кода выдавали ошибку на этапе компиляции.</li>
</ul>
<hr>
<table>
<tbody><tr><td><b>1</b>. <a href="https://docs.python.org/reference/lexical_analysis.html#indentation">https://docs.python.org/reference/lexical_analysis.html#indentation</a><br>
<blockquote>The indentation levels of consecutive lines are used to generate INDENT and DEDENT tokens, using a stack, as follows.</blockquote>
<br>
<b>2</b>. <a href="https://github.com/11l-lang/python_to_11l/blob/master/tokenizer.py">https://github.com/11l-lang/python_to_11l/blob/master/tokenizer.py</a><br>
<pre class="code_block"><span class="identifier">prev_indentation_level</span> = <span class="identifier">indentation_levels</span>[-<span class="numeric-literal">1</span>] ...

<span class="keyword">if</span> <span class="identifier">indentation_level</span> == <span class="identifier">prev_indentation_level</span>:
    <span class="identifier">tokens</span>.<span class="identifier">append</span>(<span class="identifier">Token</span>(..., <span class="identifier">STATEMENT_SEPARATOR</span>))
<span class="keyword">elif</span> <span class="identifier">indentation_level</span> &gt; <span class="identifier">prev_indentation_level</span>:
    ...
    <span class="identifier">indentation_levels</span>.<span class="identifier">append</span>(<span class="identifier">indentation_level</span>)
    <span class="identifier">tokens</span>.<span class="identifier">append</span>(<span class="identifier">Token</span>(..., <span class="identifier">INDENT</span>))
<span class="keyword">else</span>:
    <span class="keyword">while</span> <span class="constant">True</span>:
        <span class="identifier">indentation_levels</span>.<span class="identifier">pop</span>()
        <span class="identifier">tokens</span>.<span class="identifier">append</span>(<span class="identifier">Token</span>(..., <span class="identifier">DEDENT</span>))
        <span class="identifier">level</span> = <span class="identifier">indentation_levels</span>[-<span class="numeric-literal">1</span>] ...
        <span class="keyword">if</span> <span class="identifier">level</span> == <span class="identifier">indentation_level</span>:
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="identifier">level</span> &lt; <span class="identifier">indentation_level</span>:
            <span class="keyword">raise</span> <span class="identifier">Error</span>(<span class="string-literal">'unindent ...'</span>, <span class="identifier">i</span>)
</pre>
<br>
<b>3</b>. <a href="https://github.com/11l-lang/_11l_to_cpp/blob/master/tokenizer.py">https://github.com/11l-lang/_11l_to_cpp/blob/master/tokenizer.py</a><br>
</td></tr>
</tbody></table>
Теперь к вопросу реализации.<!--[[[\Implementation notes]]]--> Краткое описание алгоритма учёта отступов приводится в документации к языку программирования Python. Ссылка указана на слайде. Вкратце алгоритм работает так: в начале каждой строки уровень отступа сравнивается со значением в вершине специального стека. Если он больше, тогда он помещается в стек и лексический анализатор генерирует токен INDENT. А если меньше, то из стека удаляются все значения превышающие уровень отступа текущей строки и на каждое удаленное значение генерируется токен DEDENT. Также в конце исходного файла генерируется DEDENT для каждого оставшегося в стеке значения.<br>
<br>
Вторая ссылка ведёт к реализации лексического анализатора транспайлера, преобразующего исходный код на языке Python в код на новом языке программирования 11l. На слайде представлена краткая выдержка кода, соответствующего реализации алгоритма учёта отступов.<br>
<br>
Третья ссылка относится к реализации лексического анализатора нового языка программирования 11l, который основан на отступах как и лексический анализатор языка Python, однако в новом языке добавлена поддержка фигурных скобок, что позволяет писать код в одну строку, либо без отступа:<br>
<hr>
<table>
<tbody><tr><td>С отступом:<br>
<pre class="code_block"><span class="keyword">fn</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
   <span class="keyword">return</span> <span class="identifier">a</span> + <span class="identifier">b</span>
</pre>
<br>
В одну строку:<br>
<pre class="code_block"><span class="keyword">fn</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>) {<span class="keyword">return</span> <span class="identifier">a</span> + <span class="identifier">b</span>}
</pre>
<br>
Без отступа:<br>
<pre class="code_block"><span class="keyword">fn</span> <span class="identifier">sum</span>(<span class="identifier">a</span>, <span class="identifier">b</span>)
{
<span class="keyword">return</span> <span class="identifier">a</span> + <span class="identifier">b</span>
}
</pre>
</td></tr>
</tbody></table>
<!--[[[
Поддержка фигурных скобок в 11l позволяет писать код в одну строку либо без отступа.
]]]-->Такое решение является наиболее универсальным и придётся по вкусу<span class="sq"><span class="sq_brackets">[</span>?<span class="sq_brackets">]</span></span> как любителям фигурных скобочек, так и приверженцам<span class="sq"><span class="sq_brackets">[</span>?<span class="sq_brackets">]</span></span> отступов.<!--[[[
Главной целью данного доклада является акцентирование внимания разработчиков новых языков программирования на значимость отступов, так как на данный момент времени при разработке новых языков программирования по-прежнему доминирует устаревшая концепция, появившаяся в языке BCPL и популяризованная[https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages ‘This syntax originated with BCPL (1966), and was popularized by C.’] посредством языка Си.]]]--><!--[[[
Цель[[[ю]]] данного доклада [[[является]]]— показать значимость учёта отступов при разработке синтаксиса языков программирования.]]]--><br>
<hr>
<table>
<tbody><tr><td><br>
<a href="http://alextretyak.ru/conf">alextretyak.ru/conf</a><br>
<br>
</td></tr>
</tbody></table>
В электронном формате данный доклад доступен по этому адресу.</div>

</body></html>