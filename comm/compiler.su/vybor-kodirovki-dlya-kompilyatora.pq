Н‘‘Выбор кодировки для компилятора (ссылка на статью)’[http://compiler.su/vybor-kodirovki-dlya-kompilyatora.php]’

Комментарии:
Т‘
‘‘*‘2021-01-17’ ~‘alextretyak’

> Если в язык добавляем поддержку кириллицы, то разбор уже такой:
Тут наверное ошибка — имеется в виду «добавляем поддержку русского алфавита», а не кириллицы[https://ru.wikipedia.org/wiki/Кириллица].
[Причём «русского алфавита без буквы ё» :)(:.]
[[[[
(==      &#124;&#124; ( 'A' <= символ && символ <= 'Я' &#124;&#124; 'a' <= символ && символ <= 'я')==)
А как же буква «ё»?
Во всех известных мне кодировках, поддерживающих русский язык (1251, 866, KOI8-R и даже в Юникоде), буква «ё» находится за пределами диапазона от «а» до «я», поэтому необходимо добавить отдельную проверку на «ё» и «Ё».
]]]]
>‘#(C)‘
    if (! (массив признаков [символ] && ПЕРВЫЙ СИМВОЛ ИДЕНТИФИКАТОРА ))
    ...
        if (! (массив признаков [символ] && СЛЕДУЮЩИЙ СИМВОЛ ИДЕНТИФИКАТОРА ))
’’
Как я предполагаю ~‘ПЕРВЫЙ СИМВОЛ ИДЕНТИФИКАТОРА’ это константа 1, а ~‘СЛЕДУЮЩИЙ СИМВОЛ ИДЕНТИФИКАТОРА’ — это константа 2.
Но в таком случае следует использовать поразрядное И (&), а не логическое (&&).
[[[[
Статья слишком теоретическая.
Попробую восполнить этот недостаток посредством данного комментария.]]]][[[[
Теперь пара замечаний с точки зрения практического использования. Признаки может быть выгоднее хранить не в одном массиве, а в разных — по одному массиву из одноразрядных значений (std::vector<bool>) на каждый признак.
]]]]

Признаю целесообразность ограничиться только поддержкой базовой плоскости Юникода (первые 65536 символов), тогда реализация в виде простого массива из 65536 элементов почти оптимальна. Но если поразмышлять на этот счёт...
Если посмотреть в ‘документацию MSVC’[https://docs.microsoft.com/en-us/cpp/cpp/identifiers-cpp?view=msvc-140], то там приводятся конкретные диапазоны символов Юникода, которые можно использовать в идентификаторах. Наибольший код допустимого в идентификаторах символа составляет EFFFD, что в десятичной системе — 983037. Таким образом, потребуется массив из 983038 элементов. Но. А что, если признаки символов хранить не в одном массиве, а в разных — по одному массиву на каждый признак. И если вместо массива использовать hash-set\хэш-множество. Я [[[[не поленился и ]]]]написал простенькую программу[https://www.dropbox.com/s/ixpifmqdu818in2/MSVC_Identifiers.py?dl=0], которая суммирует все диапазоны из документации MSVC и, таким образом, считает сколько символов допустимо использовать в идентификаторах в MSVC. Получилось 971380. Теперь, вместо того, чтобы хранить символы, которые допустимо использовать в идентификаторах, можно хранить только недопустимые, ведь их всего лишь 11658 (983038 - 971380)!

P.S. Вопрос автору сайта: а почему символ «'‘&#124;’'» [даже внутри блока кода] заменяется на «!» (восклицательный знак) при нажатии на «Предварительный просмотр»?’’
’